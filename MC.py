import numpy as np
import pandas as pd

from simulator import Simulator
from brownian_motion import BrownianMotion

class MonteCarlo:
    """
    A class used to perform Monte Carlo simulations of delta hedged option portfolios
    """

    def __init__(self):
        """
        Initializer requires no arguments, arguments are directly passed to functions
        """
        pass

    def run_monte_carlo(self, *, n_paths, base_seed, S0, mu, sigma_true, T, K, sigma_model, r, num_hedges, n_options,
                        transaction_bps, integer_stocks, DT):
        """
        Run a Monte Carlo simulation of a discretely delta-hedged option portfolio.

        Stock price paths are generated using a geometric Brownian motion with true
        volatility `sigma_true`. The option is priced and hedged using model volatility
        `sigma_model`.

        NOTE: This function uses full market-to-market timesteps(the timesteps of the simulated stock price)
              and NOT only the hedging timesteps.

        :param n_paths: Number of Monte Carlo stock price paths to simulate
        :param base_seed: Base random seed to generate stock prices
        :param S0: Initial stock price (float)
        :param mu: drift of the stock price (float)
        :param sigma_true: true volatility of the stock price (float)
        :param T: Time to maturity of the option in years (float)
        :param K: Strike price of option (float)
        :param sigma_model: volatility assumed by hedging model when computing options prices (float)
        :param r: risk-free rate (float)
        :param num_hedges: number of times to hedge over the life of the option(int)
        :param n_options: number of options held in the portfolio (int)
        :param transaction_bps: transaction costs in bps (int)
        :param integer_stocks: If True stocks held will be rounded to nearest integer (int)
        :param DT: Time step of the stock price simulation in years.
        :return:
        """
        sim = Simulator(time_unit="days", transaction_fee_bps=transaction_bps, integer_stocks=integer_stocks)

        #Defining seeds for stock prices
        rng = np.random.default_rng(int(base_seed))
        seeds = rng.integers(low=0, high=2**32-1, size=n_paths)

        #Initializing result arrays
        pnl_terminal = np.empty(int(n_paths), dtype=float)
        tc_total = np.empty(int(n_paths), dtype=float)
        turnover = np.empty(int(n_paths), dtype=float)
        max_abs_delta = np.empty(int(n_paths), dtype=float)

        #Creating brownian motion object
        bm = BrownianMotion(x_0=S0, t=T, delta_t=DT, mu=mu, sigma=sigma_true)

        #Running Monte Carlo Simulation
        for i, seed in enumerate(seeds):
            stock_prices = bm.geometric_brownian_motion(seed=int(seed))

            #Creating the full time index dataframe
            df_full, _ = sim.run_path(num_options=int(n_options), stock_time_step=DT, num_hedges=int(num_hedges),
                                      sigma_model=sigma_model, risk_free_rate=r, option_strike_price=K,
                                      init_cash_balance=50000, stock_prices=stock_prices)

            #Computing key statistics
            pnl_terminal[i] = float(df_full["Total Pnl"].iloc[-1])
            tc_total[i] = float(df_full["Transaction costs"].sum())
            turnover[i] = float(df_full["Hedge in this timestep"].abs().sum())

            overall_delta = df_full["Shares held"] + df_full["Options held"] * df_full["Option Delta"]

            max_abs_delta[i] = float(overall_delta.abs().max())

        return {"Final PnL": pnl_terminal, "Total Transaction Costs": tc_total, "Turnover": turnover,
                "Max Absolute Delta": max_abs_delta}

    def summarize_mc(self, res: dict):
        """
        Helper function that summarizes the data generated by the Monte Carlo simulation.
        :param res: A result dictionary as generated by the run_monte_carlo function
                Required keys:
                - "Final PnL": array-like of terminal profit and loss values
                - "Total Transaction Costs": array-like of total transaction costs
                - "Turnover": array-like of total turnover
                - "Max Absolute Delta": array-like of maximum absolute delta exposure
        :return: Dictionary with the following entries:
                 - "mean_pnl": Mean of terminal PnL
                 - "std_pnl": Sample standard deviation of terminal PnL
                 - "var5": 5% Value-at-Risk (lower tail quantile of PnL)
                 - "var95": 95% quantile of PnL
                 - "es5": Expected Shortfall at 5% (mean PnL below the 5% VaR)
                 - "mean_tc": Mean total transaction costs
                 - "mean_turnover": Mean turnover
                 - "mean_max_abs_delta": Mean maximum absolute delta exposure
        """
        pnl = res["Final PnL"]

        #5th and 95th percentile of PnL
        p5 = float(np.quantile(pnl, 0.05))
        p95 = float(np.quantile(pnl, 0.95))

        #Mean of the worst 5% of pnl
        es5 = float(np.mean(pnl[pnl <= p5]))

        return {
            "mean_pnl": float(np.mean(pnl)),
            "std_pnl": float(np.std(pnl, ddof=1)) if len(pnl) > 1 else 0.0,
            "var5": p5,
            "var95": p95,
            "es5": es5,
            "mean_tc": float(np.mean(res["Total Transaction Costs"])),
            "mean_turnover": float(np.mean(res["Turnover"])),
            "mean_max_abs_delta": float(np.mean(res["Max Absolute Delta"])),
        }